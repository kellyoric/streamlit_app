# -*- coding: utf-8 -*-
"""Copie_de_marketing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1POpNSbBscniPdAWfpE8zS1B-kFf6jwY4

#  Analyse des donn√©es de transport des √©tudiants de l'ENSEA
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import plotly.io as pio
import re
from collections import Counter
#pio.renderers.default = 'notebook'  # ou 'iframe', 'browser', 'colab' selon l'environnement

"""# Chargement et pr√©paration des donn√©es"""

data=pd.read_csv('cleaned_dataset.csv')
data=data.drop(columns=['Unnamed: 0'])
data.head()

#from google.colab import drive
#drive.mount('/content/drive')

"""# Analyse univari√©e avec Plotly

## R√©partition par sexe
"""

# Comptage des occurrences
sexe_counts = data["sex"].value_counts().reset_index()
sexe_counts.columns = ['Sexe', 'Effectif']

# Cr√©ation du pie chart
couleurs = {'masculin': '#4682B4', 'feminin': 'lightpink'}
fig = px.pie(sexe_counts, names='Sexe', values='Effectif', title="R√©partition des √©tudiants par Sexe", color='Sexe', color_discrete_map=couleurs)
fig.update_layout(width=600, height=400, title_x=0.5, title_font=dict(size=25, color="black"))

# Affichage du graphique
fig.show()

"""## R√©partition simple par tranche d'√¢ge"""

age_counts = data['age'].value_counts().reset_index()
age_counts.columns = ['Tranche d\'√¢ge', 'Effectif']

fig = px.bar(age_counts, x='Effectif', y='Tranche d\'√¢ge', orientation='h',
             text='Effectif',
             title="R√©partition des √©tudiants par tranche d'√¢ge",
             color='Tranche d\'√¢ge',
             color_discrete_sequence=px.colors.sequential.Blues_r)

fig.update_layout(title_x=0.5,
                  title_font_size=22,
                  xaxis_title="Nombre d'√©tudiants",
                  yaxis_title="Tranche d'√¢ge",
                  height=500)
fig.show()

"""## R√©partition des √©tudiants par fili√®re"""

liste = []
for element in data["course"].values:
    if element == "ise":
        element="ISE"
        liste.append(element)
    elif element == "as":
        element = "AS"
        liste.append(element)
    else:
        element == None
        liste.append(element)
data["course"] = liste

# üîπ √âtape 1 : Compter le nombre d'√©tudiants par classe et fili√®re
data_counts = data.groupby(['course', 'class']).size().reset_index(name='Effectif')

# üîπ √âtape 2 : D√©finir des couleurs en d√©grad√© pour chaque classe
colors = {
    'as1': '#1f77b4', 'as2': '#6baed6', 'as3': '#c6dbef',  # D√©grad√© de bleu pour AS
    'ise1': '#ff7f0e', 'ise2': '#ffa07a', 'ise3': '#ffcc99'  # D√©grad√© d'orange pour ISE
}

# üîπ √âtape 3 : Cr√©ation du graphique en barres empil√©es
fig = px.bar(data_counts, x='course', y='Effectif', color=('class'),
             title="R√©partition des √©tudiants par Fili√®re et Classe",
             text='Effectif',  # Afficher les effectifs sur les barres
             barmode='stack',  # Mode empil√©
             color_discrete_map=colors)  # Appliquer le d√©grad√© de couleurs

# üîπ √âtape 4 : Personnalisation du graphique
fig.update_layout(
    title_x=0.5,  # Centrer le titre
    xaxis_title="Fili√®re",  # Nom de l'axe X
    yaxis_title="Nombre d'√©tudiants",  # Nom de l'axe Y
    legend_title="Classes",  # Titre de la l√©gende
    width=800, height=500,  # Taille du graphique
    title_font=dict(size=25, color="black")
)

# √âtape 5 : Affichage du graphique
fig.show()

# === Visualisations vari√©es pour variables cat√©gorielles ===
variables_to_plot = {
    "main_service": "Services de transport utilis√©s",
    "mean_time": "Dur√©e moyenne actuelle du trajet",
    "mean_time_wanted": "Dur√©e de trajet souhait√©e",
    "criteria": "Crit√®re principal de choix du service",
    "services": "Souhait de services suppl√©mentaires",
    "vehicle_type": "Type de v√©hicule pr√©f√©r√©",
    "even_transport": "Souhait de transport en soir√©e"
}

# Alternance de types de graphiques pour √©viter la redondance
orientation_cycle = ['v', 'h']
orient_index = 0

# Couleur bleu acier pour la nationalit√©
steel_blue = ['#4682B4']

# Palettes esth√©tiques pour les autres graphiques
pastel_palette = px.colors.qualitative.Pastel
vibrant_palette = px.colors.qualitative.Bold
soft_palette = px.colors.qualitative.Safe

for i, (var, title) in enumerate(variables_to_plot.items()):
    counts = data[var].value_counts().reset_index()
    counts.columns = [var.capitalize(), 'Effectif']
    orientation = orientation_cycle[orient_index % len(orientation_cycle)]
    orient_index += 1

    # S√©lection des couleurs en fonction de la variable
    if var == "nationality":
        colors = steel_blue
        show_color_var = False  # Ne pas diff√©rencier par couleur dans les graphiques en barres
    elif var in ["main_service", "criteria"]:
        colors = pastel_palette
        show_color_var = True
    elif var in ["mean_time", "mean_time_wanted"]:
        colors = vibrant_palette
        show_color_var = True
    else:
        colors = soft_palette
        show_color_var = True

    if counts.shape[0] <= 3:
        fig = px.pie(counts, names=var.capitalize(), values='Effectif', title=title,
                     color_discrete_sequence=colors)
    else:
        if orientation == 'v':
            if var == "nationality":
                # Pour nationalit√©: une seule couleur sans diff√©renciation
                fig = px.bar(counts, x=var.capitalize(), y='Effectif', text='Effectif', title=title,
                             color_discrete_sequence=colors)
            else:
                # Pour les autres: coloration par cat√©gorie
                fig = px.bar(counts, x=var.capitalize(), y='Effectif', text='Effectif', title=title,
                             color=var.capitalize() if show_color_var else None,
                             color_discrete_sequence=colors)
        else:
            if var == "nationality":
                # Pour nationalit√©: une seule couleur sans diff√©renciation
                fig = px.bar(counts, y=var.capitalize(), x='Effectif', orientation='h',
                             text='Effectif', title=title, color_discrete_sequence=colors)
            else:
                # Pour les autres: coloration par cat√©gorie
                fig = px.bar(counts, y=var.capitalize(), x='Effectif', orientation='h',
                             text='Effectif', title=title,
                             color=var.capitalize() if show_color_var else None,
                             color_discrete_sequence=colors)

    fig.update_layout(width=900, height=500, title_x=0.5, title_font=dict(size=22))
    fig.update_traces(textposition='auto')
    fig.show()

"""## R√©partition des services supplementaires"""

def normaliser_terme(terme):
    equivalences = {
        'wi-fi': 'wifi', 'wi fi': 'wifi', 'wifi': 'wifi', 'Wifi': 'wifi', 'Wi-Fi': 'wifi', 'Wi-fi': 'wifi',
        'usb': 'usb', 'prise': 'usb', 'prise usb': 'usb', 'chargeur': 'usb',
        'eau': 'eau', "l'eau": 'eau',
        'clim': 'climatisation', 'climatisation': 'climatisation', 'climatisatio': 'climatisation', 'la clim': 'climatisation',
        'musique': 'musique'
    }
    return equivalences.get(terme.strip().lower(), terme.strip().lower())

# === Liste des termes √† exclure (stop words) ===
STOP_WORDS = {"de", "des", "le", "la", "les", "et", "l'", "un", "une", "d'", "√†", "au", "aux", "du"}

# === Analyse des services avec exclusion des mots ind√©sirables ===
def analyser_services_simplifie(data, colonne):
    compteur = Counter()
    for val in data[colonne].dropna().astype(str):
        elements = re.split(r'[;,/\\|\n\s]+', val)  # Meilleure gestion des s√©parateurs
        services_uniques = set()
        for el in elements:
            el_clean = normaliser_terme(el)
            if el_clean and el_clean not in STOP_WORDS:  # Exclusion des mots ind√©sirables
                services_uniques.add(el_clean)
        for item in services_uniques:
            compteur[item] += 1
    return pd.DataFrame(compteur.items(), columns=["Service", "Occurrences"]).sort_values(by="Occurrences", ascending=False)

# === Suppression des modalit√©s compos√©es si leurs √©l√©ments existent d√©j√† ===
def nettoyer_modalites_composes(data_services):
    services_exacts = set(data_services["Service"].values)
    lignes_a_supprimer = []
    for idx, service in data_services["Service"].items():
        composants = re.split(r'[\\s\\-_]+', service)
        composants = [c for c in composants if c in services_exacts and c != service]
        if len(composants) >= 2:
            lignes_a_supprimer.append(idx)
    return data_services.drop(lignes_a_supprimer).reset_index(drop=True)



# === Application des traitements ===
services_data = analyser_services_simplifie(data, 'other_services')
services_data_final = nettoyer_modalites_composes(services_data)

from wordcloud import WordCloud
import matplotlib.pyplot as plt

# === G√©n√©ration du dictionnaire {mot: fr√©quence}
frequences = dict(zip(services_data_final["Service"], services_data_final["Occurrences"]))

# === Cr√©ation du nuage de mots
wordcloud = WordCloud(width=800, height=400, background_color='white', colormap='viridis').generate_from_frequencies(frequences)

# === Affichage
plt.figure(figsize=(14, 7))
plt.imshow(wordcloud, interpolation='bilinear')
plt.axis('off')
plt.title("Nuage de mots des services suppl√©mentaires demand√©s", fontsize=20)
plt.tight_layout()
plt.show()

"""### Les attentes en mati√®re de prix sont-elles r√©alistes ?"""

# Nettoyage - garder seulement les modalit√©s valides
modalites_valides = ['moins_1000', 'frs_1000_1500', 'frs_1500_2000', 'plus_2000']

data_clean = data[
    data['price_vehicle'].isin(modalites_valides) &
    data['price_wanted'].isin(modalites_valides)
].copy()

# Ordonner les cat√©gories
ordre_categories = ['moins_1000', 'frs_1000_1500', 'frs_1500_2000', 'plus_2000']
data_clean['price_vehicle'] = pd.Categorical(data_clean['price_vehicle'], categories=ordre_categories, ordered=True)
data_clean['price_wanted'] = pd.Categorical(data_clean['price_wanted'], categories=ordre_categories, ordered=True)

# Pr√©paration pour visualisation comparative
df_compare = pd.DataFrame({
    'Tranche de prix': ordre_categories * 2,
    'Proportion': [
        (data_clean['price_vehicle'] == cat).mean() for cat in ordre_categories
    ] + [
        (data_clean['price_wanted'] == cat).mean() for cat in ordre_categories
    ],
    'Type': ['Actuel']*4 + ['Souhait√©']*4
})

# Visualisation en barres group√©es
fig = px.bar(df_compare,
             x='Tranche de prix',
             y='Proportion',
             color='Type',
             barmode='group',
             title='R√©partition des tranches de prix actuelles vs souhait√©es',
             labels={'Proportion': 'Proportion des r√©pondants'},
             color_discrete_map={'Actuel': '#e74c3c', 'Souhait√©': '#2ecc71'},
             height=500)

# Am√©liorations visuelles
fig.update_layout(
    title_x=0.5,
    xaxis_title='Tranche de prix (FCFA)',
    yaxis_tickformat='.0%',
    hovermode='x unified',
    plot_bgcolor='white'
)

fig.update_traces(
    hovertemplate='<b>%{x}</b><br>Proportion: %{y:.1%}',
    texttemplate='%{y:.0%}',
    textposition='outside'
)

# Ajouter les libell√©s complets
libelles = {
    'moins_1000': '<1000',
    'frs_1000_1500': '1000-1500',
    'frs_1500_2000': '1500-2000',
    'plus_2000': '>2000'
}

fig.update_xaxes(
    ticktext=[libelles[cat] for cat in ordre_categories],
    tickvals=ordre_categories
)

fig.show()

"""# Analyse bivari√©e avec Plotly

## Les gar√ßons et les filles utilisent-ils les m√™mes services de transport ?
"""

# Pr√©paration des donn√©es
data_sexe_service = data[['sex', 'main_service']].dropna()
data_sexe_service['sex'] = data_sexe_service['sex'].str.lower().str.strip()

# Comptage
grouped = data_sexe_service.groupby(['sex', 'main_service']).size().reset_index(name='Effectif')

# D√©finition des couleurs personnalis√©es
color_map = {'masculin': '#4682B4', 'feminin': 'lightpink'}

# Visualisation
fig = px.bar(grouped, x='main_service', y='Effectif', color='sex', barmode='group',
             text='Effectif',
             title="Les gar√ßons et les filles utilisent-ils les m√™mes services de transport ?",
             labels={'sex': 'Sexe', 'main_service': 'Service utilis√©'},
             color_discrete_map=color_map)  # Application de la palette de couleurs personnalis√©e

fig.update_layout(title_x=0.5, title_font_size=22,
                  xaxis_title="Service utilis√©", yaxis_title="Nombre d'√©tudiants",
                  legend_title="Sexe", height=500)
fig.update_traces(textposition='outside')
fig.show()

"""### Quels services de transport selon les classes d‚Äô√¢ge ?"""

# Nettoyage de la base
df = data.dropna(subset=['age', 'main_service'])

# Regroupement par tranche d'√¢ge et service
grouped = df.groupby(['age', 'main_service'], observed=True).size().reset_index(name='Effectif')

# Renommer pour lisibilit√©
grouped.rename(columns={'age': 'Tranche d‚Äô√¢ge'}, inplace=True)

# Calcul des effectifs totaux par tranche d'√¢ge
total_par_age = grouped.groupby('Tranche d‚Äô√¢ge')['Effectif'].sum().reset_index(name='Total_Effectif')

# Fusion avec les donn√©es group√©es
grouped = grouped.merge(total_par_age, on='Tranche d‚Äô√¢ge')

# Calcul des proportions pond√©r√©es par l'effectif total
grouped['Proportion_ponderee'] = (grouped['Effectif'] / grouped['Total_Effectif']) * grouped['Total_Effectif']

# Visualisation avec hauteur proportionnelle √† l'effectif
fig = px.bar(grouped,
             x='Tranche d‚Äô√¢ge',
             y='Proportion_ponderee',
             color='main_service',
             title="Quels services de transport selon les classes d‚Äô√¢ge ? ",
             labels={'main_service': 'Service de transport', 'Proportion_ponderee': 'Effectif pond√©r√©'},
             text=grouped['Effectif'].astype(str) + ' (' + (grouped['Effectif']/grouped['Total_Effectif']*100).round(1).astype(str) + '%)',
             barmode='stack',
             height=500,
             color_discrete_sequence=px.colors.qualitative.Vivid)

fig.update_layout(title_x=0.5,
                 title_font_size=22,
                 xaxis_title="Tranche d‚Äô√¢ge",
                 yaxis_title="Effectif pond√©r√© ")
fig.update_traces(textposition='inside')
fig.show()

"""### Les crit√®res de choix du transport diff√®rent-ils selon le sexe ?"""

# Nettoyage
data['sex'] = data['sex'].str.lower().str.strip()
df = df.dropna(subset=['sex', 'criteria'])

# Groupement
grouped = df.groupby(['sex', 'criteria'], observed=True).size().reset_index(name='Effectif')

# Calcul des proportions par sexe
total_par_sexe = grouped.groupby('sex')['Effectif'].transform('sum')
grouped['Proportion'] = grouped['Effectif'] / total_par_sexe * 100

# Affichage des proportions en barres empil√©es
fig = px.bar(grouped, y='sex', x='Proportion', color='criteria',
             title="Les crit√®res de choix du transport diff√®rent-ils selon le sexe ?",
             labels={'sex': 'Sexe', 'criteria': 'Crit√®re de choix'},
             text=grouped['Proportion'].round(1).astype(str) + '%',
             orientation='h', color_discrete_sequence=px.colors.qualitative.Prism)

fig.update_layout(title_x=0.5, title_font_size=22,
                  xaxis_title="Part (%) des crit√®res", yaxis_title="Sexe",
                  barmode='stack', height=500)
fig.update_traces(textposition='inside')
fig.show()

# Nettoyages
data['criteria'] = data['criteria'].str.lower().str.strip()
data['vehicle_type'] = data['vehicle_type'].str.lower().str.strip()

# Analyse : crit√®res √ó type de v√©hicule
df1 = data.dropna(subset=['criteria', 'vehicle_type'])
grouped1 = df1.groupby(['criteria', 'vehicle_type'], observed=True).size().reset_index(name='Effectif')

# Calcul des proportions
total_criteria = grouped1.groupby('criteria')['Effectif'].transform('sum')
grouped1['Proportion'] = grouped1['Effectif'] / total_criteria * 100

# Visualisation
fig1 = px.bar(grouped1, y='criteria', x='Proportion', color='vehicle_type',
              title="Quel type de v√©hicule veulent les √©tudiants selon leur crit√®re principal ?",
              text=grouped1['Proportion'].round(1).astype(str) + '%',
              orientation='h', barmode='stack',
              color_discrete_sequence=px.colors.qualitative.Set2)

fig1.update_layout(title_x=0.5, title_font_size=22,
                   xaxis_title="Part (%)", yaxis_title="Crit√®re de choix")
fig1.update_traces(textposition='inside')
fig1.show()

# Nettoyage
data['even_transport'] = data['even_transport'].str.lower().str.strip()
data['class'] = data['class'].astype(str).str.strip()

# Filtrer les donn√©es valides
df_even = data.dropna(subset=['even_transport', 'class'])

# Regrouper
grouped_even = df_even.groupby(['class', 'even_transport'], observed=True).size().reset_index(name='Effectif')

# Calcul de proportions par classe
total_par_classe = grouped_even.groupby('class')['Effectif'].transform('sum')
grouped_even['Proportion'] = grouped_even['Effectif'] / total_par_classe * 100

# Visualisation (barres group√©es)
fig2 = px.bar(grouped_even, x='class', y='Proportion', color='even_transport',
              title="Qui veut vraiment du transport en soir√©e (par niveau de classe) ?",
              text=grouped_even['Proportion'].round(1).astype(str) + '%',
              barmode='group',
              labels={'class': 'Niveau de classe', 'even_transport': 'Souhaite un transport en soir√©e'},
              color_discrete_sequence=px.colors.qualitative.Bold)

fig2.update_layout(title_x=0.5, title_font_size=22,
                   yaxis_title="Part (%)", xaxis_title="Classe",
                   height=500)
fig2.update_traces(textposition='outside')
fig2.show()

"""## NPS global par service"""

# √âtape 1 : pr√©paration des donn√©es
data_clean = data[['main_service', 'nps']].dropna()
data_clean['nps'] = pd.to_numeric(data_clean['nps'], errors='coerce')
data_clean = data_clean.dropna()

# √âtape 2 : cat√©gorisation
def classify_nps(score):
    if score >= 9:
        return 'Promoteur'
    elif score >= 7:
        return 'Passif'
    else:
        return 'D√©tracteur'

data_clean['NPS_category'] = data_clean['nps'].apply(classify_nps)

# √âtape 3 : calcul du score NPS pour chaque service
def compute_nps(group):
    total = len(group)
    promoters = len(group[group == 'Promoteur'])
    detractors = len(group[group == 'D√©tracteur'])
    return round(((promoters - detractors) / total) * 100, 1)

nps_by_service = data_clean.groupby('main_service')['NPS_category'].apply(compute_nps).reset_index()
nps_by_service.columns = ['Service', 'NPS']

# √âtape 4 : visualisation avec Plotly
import plotly.express as px

fig = px.bar(nps_by_service, x='Service', y='NPS', text='NPS',
             title='Score NPS global par service de transport',
             color='NPS', color_continuous_scale='Tealgrn')

fig.update_traces(textposition='outside')
fig.update_layout(title_x=0.5, title_font_size=22,
                  yaxis_title='Score NPS', xaxis_title='Service',
                  height=500)
fig.show()

# NPS par service avec Plotly (barres empil√©es)
data_clean = data[['main_service', 'nps']].dropna()
data_clean['nps'] = pd.to_numeric(data_clean['nps'], errors='coerce')
data_clean = data_clean.dropna()
data_clean['NPS_category'] = data_clean['nps'].apply(classify_nps)

nps_grouped = data_clean.groupby(['main_service', 'NPS_category']).size().reset_index(name='count')
fig2 = px.bar(nps_grouped, x='main_service', y='count', color='NPS_category', text='count',
              title="R√©partition des cat√©gorie NPS par service ",
              color_discrete_map={
                  'D√©tracteur': 'red', 'Passif': 'orange', 'Promoteur': 'green'
              })
fig2.update_layout(barmode='stack', title_x=0.5, title_font_size=20,
                   xaxis_title="Service de transport", yaxis_title="Nombre d'√©tudiants")
fig2.show()

